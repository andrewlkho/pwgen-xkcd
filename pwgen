#!/usr/bin/awk -f

BEGIN {
    ############################################################################
    # Specify either the number of words per password (total_x) or the total
    # length of the password (total_len).  Whichever is non-zero is used;
    # if both a non-zero then total_len takes precedence.
    total_x = 0
    total_len = 32

    # Maximum number of characters per word
    max_chars = 9

    # Separator between words in the password:
    sep = "-"

    # Capitalise the first word (helps with password-checking algorithms which
    # require an upper case letter) -- 1 = yes, 0 = no
    capitalise = 1

    # Append a number (rationale same as above)
    number = 1
    ############################################################################

    # Read in the list of words
    ARGV[1] = ARGV[1] ? ARGV[1] : "eff_large_wordlist.txt"
    ARGC = ARGC > 2 ? ARGC : 2

    # Seed the random number generator
    srand()

    # Sanity check
    max_chars = (max_chars >= 3 && max_chars <= 9) ? max_chars : 9
}

# Select appropriate words into the array `words`
$2 ~ /^[a-zA-Z]+$/ && length($2) <= max_chars {
    words[i++] = $2
}

END {
    # Sanity check: there should be over 1000 elements in the array `words`
    # regardless of which EFF dictionary you use
    if (i < 1000) {
        print "Insufficient words: did you specify the correct dictionary?"
        exit -1
    }

    if (total_len) {
        # running_len is the complete length of the password that would be
        # generated based on the output_arr so far
        running_len = number

        while (running_len < total_len) {
            if ((total_len - running_len) <= (length(sep) + max_chars)) {
                # Room for one more word of exact length:
                # total_len - running_len - length(sep)
                while (length(words[try_index]) != (total_len - running_len - length(sep))) {
                    try_index = int(i * rand())
                }
            } else if ((total_len - running_len) < (length(sep) + max_chars + length(sep) + 3)) {
                # A bit more room but not too long otherwise there won't be 
                # enough space for the second word
                while ((! words[try_index]) || length(words[try_index]) > (total_len - running_len - (length(sep) + 3 + length(sep)))) {
                    try_index = int(i * rand())
                }
            } else {
                # Enough room for any word
                while (! words[try_index]) {
                    try_index = int(i * rand())
                }
            }
            output_arr[++x] = words[try_index]
            running_len += length(sep) + length(words[try_index])
            delete words[try_index]
        }
    } else if (total_x) {
        for (x = 1; x <= total_x; x++) {
            while (! words[try_index]) {
                try_index = int(i * rand())
            }
            output_arr[x] = words[try_index]
            delete words[try_index]
        }
    } else {
        print "Error: both `len` and `total_x` are zero"
        exit -1
    }

    # Join the words together
    for (w in output_arr) {
        output = output sep output_arr[w]
    }
    output = substr(tolower(output), length(sep) + 1)

    # Append a single numerical digit
    if (number) {
        output = output sep int(10 * rand())
    }

    # Capitalise the first word
    if (capitalise) {
        output = toupper(substr(output, 1, 1)) substr(output, 2)
    }

    print output
}
